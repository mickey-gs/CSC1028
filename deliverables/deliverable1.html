<!DOCTYPE html>
<html>
    <head>
        <title>Deliverable 1</title>

        <style>
            @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap');

            * {
                padding: 0;
                margin: 0;
                font-family: Poppins, sans-serif;
            }

            h1 {
                font-family: Poppins, sans-serif;
                font-size: 300%;
                line-height: 1em;
                margin-right: 1.5em;
            }

            h2 {
                font-size: 250%;
            }

            p {
                font-size: 120%;
                padding-bottom: 5px;
            }

            ul {
                padding-left: 1em;
                padding-top: 10em;
                text-decoration: underline;
            }

            #wrapper {
                display: grid;
                grid-template-columns: 1fr 5fr;
                background-color: rgb(245, 245, 245);
                width: auto;
                height: 100vh;
            }

            #sidebar {
                background-color: rgb(201, 201, 201);
                border-right: 2px dashed;
                border-right-color: rgb(145, 145, 145);
            }

            #main {
                padding: 2.5%;
            }

            #asterisk {
                text-decoration: none;
            }

            #disclaimer {
                color: gray;
                padding-top: 10px;
            }

            a:visited {
                color: blue;
            }

            ul a:visited {
                color: black;
            }

            ul a:link {
                color: black;
            }

            .codeSnippet {
                font-family: monospace;
                font-size: 120%;
                background-color: black;
                color: white;
                width: fit-content;
                line-height: 1em;
                padding: 3px;
                margin-top: 20px;
                margin-bottom: 20px;
            }
        </style>
    </head>

    <body>
        <div id="wrapper">
            <div id="sidebar">
                <ul>
                    <li><a href="#introduction">Introduction</a></li>
                    <li><a href="#good">The Good</a></li>
                    <li><a href="#bad">The Bad</a></li>
                    <li><a href="#ugly">The Ugly</a></li>
                    <li><a href="#simple">Simple Code</a></li>
                    <li><a href="#notSimple">When Should Code Not be Simple?</a></li>
                    <li><a href="#conclusion">Conclusion</a></li>
                </ul>
            </div>
            <div id="main">
                <h1>
                    A Short Guide to Every<a id="asterisk" href="#disclaimer">*</a> Programming Language
                </h1>
                <br>
                <h2 id="introduction">Introduction</h2>
                <p>
                    A common phrase to hear when learning a language is 'idiomatic code' — writing code in a style considered to be common to or appropriate for that language. This is encouraged not only to create a sense of cohesion in code written in a certain language, improving readability, but to create a sort of aesthetic unity in written programs. This piece will briefly examine the differences in use and usefulness of complex code, idiomatic code, and 'ugly' code.
                </p>

                <h2 id="good">The Good</h2>
                <p>
                    Idiomatic code looks really nice. Complex program logic which would normally take up quite a few lines for very standard program logic can be condensed to just a handful of statements. For example, let's say we're writing some data processing code in Ruby. We have an array of readings from a temperature sensor, and we want to find the mean of those readings, while filtering out outliers caused by the sensor malfunctioning.</p>
                    <pre class="codeSnippet">
// readings = [20.57, 27.68, 25.32, 23.60, 20.30, 22.47, 20.78, 28.40, 9999999.99, 24.03, 24.41, ...]

mean = readings.select { |e| e &lt;= 100 }.sum / readings.length</pre>
                <p>
                    This is nice and concise — and perfectly legible to programmers familiar to Ruby — but has some issues. The code in curly braces (known as a block) may be unfamiliar even to programmers with knowledge of anonymous functions, especially with the strange syntax of passing in a parameter with the vertical bar (also known as pipe) symbol. Additionally, method chaining following a block may be visually confusing, as most developers would be used to a method call with brackets, not braces — and the chained method call (sum) doesn't even use brackets!
                </p>

                <h2 id="bad">The Bad</h2>
                <p>
                    The issue comes when trying to write complex code in an 'idiomatic' way. The earlier example is not too diffcult for a programmer to wrap their head around, especially with a quick visit to Google, but imagine an entire codebase written in that style.     
                </p>
                <p>
                    It's undoubtedly preferable for experienced Ruby developers in an environment where Ruby will definitely be the project's main language. However, with less experienced developers or the possibility that the project will need to change to or be used in a different language, this focus on idiomatic code can seriously hamper portability and limit the developers' options via technical debt. Additionally, an internal focus on making code idiomatic and making the aesthetics of the code conform to what basically amounts to a style guide can often get in the way of 'real' programming work — debugging, adding features, refactoring old code. That's not to say that idiomatic code is a bad thing, or should always be avoided, but that it is important to recognise that having code that works and is legible is more important than code that looks nice. 

                <h2 id="ugly">The Ugly</h2>
                <p>
                    And this is the reason for 'ugly' code. At the start of a project, when the programmer isn't sure what language to be using, or when code needs to be accessible, writing basic, portable code can be very valuable. It helps to maintain language agnosticism, and stops the programmer from being locked into using a certain language or even version of a language by technical debt. It can also help avoid procrastination by trying to make code look as idiomatic or concise as possible, a trap I have myself fallen into many times. For example, we can write our example earlier as:
                </p>
                    <pre class="codeSnippet">
// readings = [20.57, 27.68, 25.32, 23.60, 20.30, 22.47, 20.78, 28.40, 9999999.99, 24.03, 24.41, ...]

// find mean by looping through array, adding up non-outliers and dividing by array length
i = 0
while (i &lt; readings.length)
    mean += readings[i] if readings[i] &lt;= 100 
    i += 1
end
mean = mean / readings.length</pre>
                <p>
                    The purpose of the code may be a little bit more obtuse due to its length, but with a comment it can be quickly understood.
                </p>
                <p>
                    More importantly, this code is <em>portable</em> — it can be easily rewritten in most commonly-used imperative languages, making the project very versatile in terms of technology. It also makes the code very widely understandable, as almost anyone with any programming experience will understand all aspects of the code with speed.
                </p>

                <h2 id="simple">Simple Code</h2>
                <p>
                    But if we're trying to avoid complexity, then how much should functionality should we take away from ourselves?
                    The requirements for a Turing complete programming language are really very minimal. One could be constructed from just assignment operations (increment, decrement and assigning to and from memory locations), conditional execution control and jump instructions. Indeed, before the advent of higher level languages such as C, many programs <em>were</em> written at this level, or slightly above it in the form of assembly code.
                </p>
                <p>
                    Needless to say, this would be a very miserable way to have to write every program. The challenge, then, is trying to decide what minimum set of features are needed to make programming as painless as possible without going too far back into complexity.
                </p>
                <p>
                    Thankfully, this work has already been done! <a href="https://dotlang.org/", target="blank">dotLang</a> is a minimalist programming language, and serves as a good example for how to go about defining this sort of standard. It is imperative, garbage collected and statically-typed, so users don't have to worry about memory management or types changing at runtime. It also features structs, first-class functions and common structures like lists and hash maps, so there is a comfortable level of abstraction to ease development. It's an imperative language, however, which does mean that a programmer using it would either have to be familiar with using recursion instead of loops, or get used to the idea very quickly.
                </p>
                <p>
                    The key idea behind dotLang is that the programmer shouldn't have to worry about his choice of tool getting in the way- it should provide the functionality needed and no more. dotLang's philosophy is that if the user needs more complicated concepts from their language, they can implement that themselves — there's even <a href="https://dotlang.org/howto", target="blank">a section on dotLang's website</a> for how to implement advanced but commonly-used concepts.
                </p>

                <h2 id="notSimple">When Should Code <em>Not</em> Be Simple?</h2>
                <p>
                    Abstractions are, by defintion, extremely useful for reducing complexity in software. They hide complexity from the user, meaning they only have to worry about implementation. This can be useful in, for example, a very large enterprise application where it isn't feasible to facilitate consistent communication between all the developers; instead of everyone needing to know everything about the entire codebase, individual teams or devs can work on implementing an object with a well-defined interface. The devs using this object do not need to understand its internals, and reducing it to an abstraction makes its incorporation into the application much easier. Additionally, maintaining these abstract, well-defined and -documented interfaces is very important for a project that may be built on for many years, long after the original developers have moved on.
                </p>
                <p>
                    On the other hand, there have been large projects where knowing the entire internals of the program were necessary — in early video game development, when games were written in rudimentary assembly and optimisation was key, memory was controlled to such a level that it was common for entities (sprites, audio etc.) and functions to have their addresses in memory hardcoded, and to reference these directly by their address.
                </p>
                <p>
                    Nowadays, technology is cheap enough that this level of optimisation is often not required, but sacrificing the ease of abstraction to gain higher performance or more low-level control over a program's control is still sometimes necessary. 
                </p>
                    <!-- Add something about modern low-level systems, like
                    maybe that missile thing from the Matt Parker book. Either way this is nearly done. Finish off with like "abstraction is sometimes good and sometimes bad. Be wise with its use, not dogmatic, or it loses its use."-->
                <h2 id="conclusion">Conclusion</h2>
                <p>
                    It's fairly clear that abstractions, including language-specific ones, can serve a valuable purpose in reducing the complexity with which program logic must be written out. The main point I would like to make with this piece is that, even though these abstractions and idioms can be very useful, following a pattern of using them dogmatically is not always necessary, and can sometimes even be harmful in terms of language lock-in and <a href="https://en.wikipedia.org/wiki/Law_of_triviality" target="_blank">bike-shedding</a>.
                </p>
                <p>
                    Abstractions are tools. Like all tools, knowing when to use them is much more valuable than knowing how to use them. Hopefully, we can be more thoughtful about when to use ours.<br>
                <q>
                    Perfection is achieved, not when there is nothing more to add, but when there is nothing less to take away.
                </q><br>
                — Antoine de Saint-Exupéry
                </p>

                <hr>
                <p id="disclaimer">
                    <em>*(imperative, procedural)</em>
                </p>
            </div>
        </div>
    </body>
</html>