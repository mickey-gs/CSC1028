Tuesday, March 11th, 2022
Just started CSC1028! Nearly didn't make it- the Undergraduate Office Supervisor sent me an email about what module I wanted to drop for this one, and I didn't see it until it was very nearly too late- thankfully she sent a followup email, which I did see. 
I felt very excited to start this module. I had completed some projects myself before starting university (which is how I got into programming and CS in the first place), and was a little disappointed in the pacing of the first term- I found the Architecture and Networks module, as well as the maths module to be quite interesting, but I was a little disappointed with the standard of the coursework for the OOP module. It was more about implementing the theoretical concepts of OOP than problem solving skills, which is perfectly understandable- it was a module for teaching a theoretical model of software- but that doesn't make it enjoyable to actually sit down and do.
So when the opportunity arose to work on a project for 6 months with no theory or exams, I grabbed it with both hands.
I also managed to secure my first choice for a project! This is a program that enables another program to be converted to an abstract form (known as an 'abstract syntax tree', or AST), and from there into a different programming language. This picks up on something that greatly interested me from the first term, but was only mentioned in passing. During the architecture section of the A&N module, it was mentioned that a compiler converts a program to 'intermediate representation' (IR) in order to apply optimisations to it, before converting it into assembly and then into binary. It was also mentioned that many different programming languages can use compilers that only have to handle conversion to IR- from there, the same toolchain can be used to generate the final executable. This interested me because it demonstrated that all programming languages were essentially so much window dressing- that they were all fundamentally the same, and code written in many different languages could be boiled down into the same form, and made equivalent to each other. This also helps remove some of the mysticism from programming languages- they are less arts to be learned, and more tools to be used. This is very reassuring to the beginner, as it can at times seem that the greatest obstacle in software development is the vast array of languages to choose from and dedicate time to learning, when in practice the language chosen for a new project is usually of not much consequence other than what the developer prefers and what libraries they need.
But that's enough background. I got started on the project today by installing npm, nvm (version manager for npm), and acorn, a utility that allows for the conversion of javascript scripts into AST format (represented as a JSON object). Despite using Javascript before, I had forgotten most of what I knew about it, and spent the majority of the time just trying to remember how to do File I/O and run scripts from the command line. Eventually, however, I did manage to produce the beginnings of the project- a small script that can convert a JS script (given as an argument on the command line) into AST, and store that AST in a .json file. The major challenge of the project will be converting AST objects back into source code. I would guess that maybe different languages can be described by JSON files? So adding a new language as a possible output would only require supplying a new JSON file linking each AST identifier to keyword(s) in that programming language. But I am sad to say that I do not think it will be that simple.
John made a big point in the lecture today (the first and only lecture!) that we should focus on making something other people can use. I think this is a good outlook- knowing that what you're working on can help other people is a great motivational tool. I think a good goal for this project would be to create the framework for converting one language to another, and make it as easy as possible for other people to adapt this and add functionality for other languages to be converted to and from. An immediate problem that springs to mind is external libraries and language-specific features, but I'll wait until my first meeting with John before I worry about that.
