Tuesday, January 11th, 2022
Just started CSC1028! Nearly didn't make it- the Undergraduate Office Supervisor sent me an email about what module I wanted to drop for this one, and I didn't see it until it was very nearly too late- thankfully she sent a followup email, which I did see. 
I felt very excited to start this module. I had completed some projects myself before starting university (which is how I got into programming and CS in the first place), and was a little disappointed in the pacing of the first term- I found the Architecture and Networks module, as well as the maths module to be quite interesting, but I was a little disappointed with the standard of the coursework for the OOP module. It was more about implementing the theoretical concepts of OOP than problem solving skills, which is perfectly understandable- it was a module for teaching a theoretical model of software- but that doesn't make it enjoyable to actually sit down and do.
So when the opportunity arose to work on a project for 6 months with no theory or exams, I grabbed it with both hands.
I also managed to secure my first choice for a project! This is a program that enables another program to be converted to an abstract form (known as an 'abstract syntax tree', or AST), and from there into a different programming language. This picks up on something that greatly interested me from the first term, but was only mentioned in passing. During the architecture section of the A&N module, it was mentioned that a compiler converts a program to 'intermediate representation' (IR) in order to apply optimisations to it, before converting it into assembly and then into binary. It was also mentioned that many different programming languages can use compilers that only have to handle conversion to IR- from there, the same toolchain can be used to generate the final executable. This interested me because it demonstrated that all programming languages were essentially so much window dressing- that they were all fundamentally the same, and code written in many different languages could be boiled down into the same form, and made equivalent to each other. This also helps remove some of the mysticism from programming languages- they are less arts to be learned, and more tools to be used. This is very reassuring to the beginner, as it can at times seem that the greatest obstacle in software development is the vast array of languages to choose from and dedicate time to learning, when in practice the language chosen for a new project is usually of not much consequence other than what the developer prefers and what libraries they need.
But that's enough background. I got started on the project today by installing npm, nvm (version manager for npm), and acorn, a utility that allows for the conversion of javascript scripts into AST format (represented as a JSON object). Despite using Javascript before, I had forgotten most of what I knew about it, and spent the majority of the time just trying to remember how to do File I/O and run scripts from the command line. Eventually, however, I did manage to produce the beginnings of the project- a small script that can convert a JS script (given as an argument on the command line) into AST, and store that AST in a .json file. The major challenge of the project will be converting AST objects back into source code. I would guess that maybe different languages can be described by JSON files? So adding a new language as a possible output would only require supplying a new JSON file linking each AST identifier to keyword(s) in that programming language. But I am sad to say that I do not think it will be that simple.
John made a big point in the lecture today (the first and only lecture!) that we should focus on making something other people can use. I think this is a good outlook- knowing that what you're working on can help other people is a great motivational tool. I think a good goal for this project would be to create the framework for converting one language to another, and make it as easy as possible for other people to adapt this and add functionality for other languages to be converted to and from. An immediate problem that springs to mind is external libraries and language-specific features, but I'll wait until my first meeting with John before I worry about that.

Wednesday, January 19th, 2022
Sat down to do some research for the project. I figured that if a library already exists for converting JavaScript to AST, then one must exist for converting AST to JavaScript. Luckily, it does!
Babel is a JavaScript library created with the purpose of 'compiling' code in newer versions of JavaScipt into older, more widely compatible versions. It also has a 'generator' which can act as a standalone converter for AST to JSON. 
(this is because the library internally does: modern JS -> AST -> older JS)
I figure that this would be a good resource, not to necessarily incorporate directly into my project, but as a reference for creating a general purpose parser for AST. I'll bring this up in the meeting.

Just had the first meeting! Discussed the immediate future of the project- I explained how Babel already exists, and the features it provides.
John agrees that it's a good resource, but thinks I should take the project in a direction that's very slightly different to what I was thinking. I was planning to implement the parser for one language completely, then move on to another; John suggested doing incremental steps in lots of languages at the same time. This is probably a better approach- it would save me the stress of creating an entire parser as the first step of my project. 
The eventual idea- the valuable end product to create- would be a tool that enables useful libraries to be ported from one language to another. I can imagine this not being too difficult for mathematical libraries (cryptography, geometric functions), but not sure yet how this will work for libraries that rely heavily on system calls, like networking and GUI libraries. I'll have to look into if it's possible to define how different languages handle system calls in a portable way (possibly JSON). 
This will all come later, though. First, I'll focus on trying to convert basic programs (hello world, arithmetic) into different languages.
I'm also thinking about creating the first deiverable, the online guide on something to do with my project. I haven't ran into any specific problems with getting my project up and running, so that seems like a non-starter. John suggested something to do with the first stage of my project, which would be less of a how-to guide, and more of an informative piece on hello world programs, and how they're written in a variety of programs. This sounds promising, because it might make a good comparative piece on language design as well as being able to show off what work I've completed so far. 
I'll make a start on that work now and see how it goes.

Friday, January 21st, 2022
Just started work on a parser for converting AST back into code. So far, I have a parser specific to JavaScript that can handle simple method calls and arithmetic (which also preserves brackets and order of operations). Was a bit hesitant to start as I expected this to be really quite difficult, but so far not too many problems have come up. The next step is to begin work on a more general parser- my target is to be able to convert to Python and Ruby at each step of the parser's implementation. I chose these languages in particular due to:
1. My familiarity with them (easy to quickly validate the output of my program)
2. Their similarities with JavaScript- both support OOP and are both interpreted and dynamically typed
I'll take a look at how Babel structures the code for its more complex parser, and then start adding on to mine.

Sunday, January 23rd, 2021
Made some good progress with the parser. I've brought it over from a basic set of functions global to the script to an organised super class (Parser), with sub classes started for JavaScript and Python. This means that I can override methods when language differences need to be taken into account (e.g. syntax for delcaring a function, ending lines with semicolons), but share methods for common functionality, like arithmetical expressions.
Quite happy with this approach, and how quickly I managed to implement it, so it looks like last term's OOP class has ended up being very heplful. 
The next step for the parser will be more complicated language features (such as functions, classes, etc), and adding in indentation (which is needed for Python to even run a script).

It's towards the end of the day now, and I've added function declarations and calls and variable declarations. It was tricky to deal with the buffer system I used for the parsers, where code was just added to a string, so I've also created a Buffer class. This makes it easier to deal with indentation, and makes interaction with the text buffer generally a lot cleaner. I've also updated the main script to produce output in both JS and Python automatically.

Monday, 24th January, 2021
More work done with the parser- if, else if, else, and while statements. I've also decided that while most work in converting AST to a specific language can be done by the parser itself, a post-processor would be useful for converting some awkward key-words: for example, Python converts "else if" into one keyword ("elif") and it's simply easier to have the post-processor replace all instances of one with the other than try to modify the parser too heavily. I'll work on some more features for the parser to take care of, and then start looking at the first deliverable.
